#' @title Add 2D Euclidean distances to cluster centroids as features
#'
#' @description
#' Adds new variables based on the 2D Euclidean distances to cluster centroids
#' in the data. These centroids are generated by k-means clustering of the
#' variables provided in 'lat' and 'lon' as well as the target variable.
#'
#' @return a `PipeOpSpatialDistCluster` object.
#' @export
#'
#' @examples
#' library(mlr3)
#' library(mlr3pipelines)
#'
#' task = tsk('boston_housing')
#' pop = PipeOpSpatialDistCluster$new()
#' pop$param_set$values$lat = 'lat'
#' pop$param_set$values$lon = 'lon'
#' pop$train(list(task))
#' pop$predict(list(task))[[1]]$data()
PipeOpSpatialDistCluster = R6::R6Class(
  'PipeOpSpatialDistCluster',
  inherit = PipeOpTaskPreprocSimple,

  public = list(

    #' @description
    #' Create a new PipeOpSpatialDistCluster object.
    #' @param id character, identifier for the class instance.
    #' @param param_vals named list of hyperparameters.
    #' @return A new `PipeOpSpatialDistCluster` object.
    initialize =
      function(id = 'spatialdist_cluster',
               param_vals = list(prefix = 'geodist', k = 5)) {
        ps = ParamSet$new(params = list(
          ParamUty$new('lat', tags = c('train', 'predict', 'required')),
          ParamUty$new('lon', tags = c('train', 'predict', 'required')),
          ParamUty$new('k', tags = c('train', 'predict', 'required')),
          ParamUty$new('prefix', tags = c('train', 'predict'), default = 'geodist')
        ))
        super$initialize(
          id,
          param_set = ps,
          param_vals = param_vals,
          feature_types = c('numeric', 'integer')
        )
      }
  ),

  private = list(
    .get_state = function(task) {
      # create cluster centroids on training
      cols = c(self$param_set$values$lat, self$param_set$values$lon)
      train_df = task$data()[, ..cols]
      km = kmeans(train_df, centers = self$param_set$values$k)
      centers = as.data.table(km$centers)
      list(
        ref_lat = centers[[self$param_set$values$lat]],
        ref_lon = centers[[self$param_set$values$lon]]
      )
    },

    .transform = function(task) {
      geo_dist_2d_calc = function(df, a, b) {
        apply(df, 1, function(x, a, b, c) {
          sqrt((x[1] - a)^2 + (x[2] - b)^2)
        },
        a = a, b = b
        )
      }

      cols = c(self$param_set$values$lat, self$param_set$values$lon)

      dist_vals = geo_dist_2d_calc(
        df = task$data()[, ..cols],
        a = self$state$ref_lat,
        b = self$state$ref_lon
      )

      if (inherits(dist_vals, 'numeric')) {
        dist_vals = data.table(dist_vals)
        data.table::setnames(
          dist_vals, names(dist_vals),
          self$param_set$values$prefix
        )
      } else if (inherits(dist_vals, 'matrix')) {
        dist_vals = as.data.table(t(dist_vals))
        data.table::setnames(
          dist_vals,
          names(dist_vals),
          paste0(self$param_set$values$prefix, seq_len(ncol(dist_vals)))
        )
      }

      task$cbind(dist_vals)
    }
  )
)
