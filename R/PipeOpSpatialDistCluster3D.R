#' @title Add 3D Euclidean distances to cluster centroids as features
#'
#' @description
#' Adds new variables based on the 3D Euclidean distances to cluster centroids
#' in the data. These centroids are generated by k-means clustering of the
#' variables provided in 'lat', 'lon', and 'depth', as well as the target
#' variable.
#'
#' @return a `PipeOpSpatialDistCluster3D` object.
#' @export
PipeOpSpatialDistCluster3D = R6::R6Class(
  "PipeOpGeodist3DCluster3D",
  inherit = mlr3pipelines::PipeOpTaskPreprocSimple,
  public = list(

    #' @description
    #' Create a new PipeOpSpatialDistCluster3D object.
    #' @param id character, identifier for the class instance.
    #' @param param_vals named list of hyperparameters.
    #' @return A new `PipeOpSpatialDistCluster3D` object.
    initialize =
      function(id = "geodist_3dcluster",
               param_vals = list(k = 10, prefix = "geodist")) {
        ps = paradox::ParamSet$new(
          params = list(
            paradox::ParamUty$new(
              id = "lat",
              tags = c("train", "predict", "required")
            ),
            paradox::ParamUty$new(
              id = "lon",
              tags = c("train", "predict", "required")
            ),
            paradox::ParamUty$new(
              id = "depth",
              tags = c("train", "predict", "required")
            ),
            paradox::ParamUty$new(
              id = "k",
              tags = c("train", "predict", "required")
            ),
            paradox::ParamUty$new(
              id = "prefix",
              tags = c("train", "predict"),
              default = "geodist"
            )
          )
        )

        super$initialize(
          id,
          param_set = ps,
          param_vals = param_vals,
          feature_types = c("numeric", "integer")
        )
      }
  ),

  private = list(
    .get_state = function(task) {
      # create cluster centroids on train
      train_df = task$data()[, .SD, .SDcols = task$feature_names]
      km = kmeans(train_df, centers = self$param_set$values$k)
      centers = as.data.table(km$centers)

      refs = list(ref_lat = centers[[self$param_set$values$lat]],
                  ref_lon = centers[[self$param_set$values$lon]],
                  ref_depth = centers[[self$param_set$values$depth]])

      return(refs)
    },

    geo_dist_3d_calc = function(x, a, b, c) {
      apply(x, 1, function(x, a, b, c) {
        sqrt((x[1] - a) ^ 2 + (x[2] - b) ^ 2 + (x[3] - c) ^ 2)
      },
      a = a, b = b, c = c)
    },

    .transform = function(task) {
      cols = c(
        self$param_set$values$lat,
        self$param_set$values$lon,
        self$param_set$values$depth
      )

      dist_vals = private$geo_dist_3d_calc(
        df = task$data()[, .SD, .SDcols = cols],
        a = self$state$ref_lat,
        b = self$state$ref_lon,
        c = self$state$ref_depth
      )

      if (inherits(dist_vals, "numeric")) {
        dist_vals = data.table(dist_vals)
        data.table::setnames(dist_vals, self$param_set$values$prefix)

      } else if (inherits(dist_vals, "matrix")) {
        dist_vals = as.data.table(t(dist_vals))
        data.table::setnames(
          dist_vals,
          paste0(self$param_set$values$prefix, seq_len(ncol(dist_vals)))
        )
      }

      task$cbind(dist_vals)
    }
  )
)
